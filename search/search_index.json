{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About this workshop","text":""},{"location":"#what-is-this-workshop-about","title":"What is this workshop about?","text":"<ul> <li>It\u2019s about dependency and package management in Python</li> <li>It\u2019s about how to share your code with others</li> <li>It\u2019s about how to share your code across projects</li> <li>And it\u2019s about how to modify your having third-party dependencies without breaking existing implementations</li> </ul> <p>It consists initially of five parts.</p>"},{"location":"#slides","title":"Slides","text":"<p>Slides are written using merp, a markdown presentation tool. You can find the slides in the <code>slides</code> folder at the root of the repository. To view them, you can use the marp for VSCode extension.</p>"},{"location":"part-1/instructions/","title":"A demonstration using Docker","text":"<p>Spoiler: you will need docker. You can get free containers using play-with-docker. You can tell if you have docker installed by running <code>docker run --rm hello-world</code>. You may need root access.</p> <p>Start by launching a new container named <code>poetry-ws-part-1</code> with the latest version of ubuntu and run a bash shell. The <code>--rm</code> flag will remove the container after you exit it so it won't clutter your system.</p> <pre><code>docker run -it --name poetry-ws-part-1 ubuntu:latest bash`\n</code></pre> <p>You can remove the container afterwards after you've exited it with</p> <pre><code>docker container rm poetry-ws-part-1\n</code></pre> <p>Editing files inside a container</p> <p>At this point you are now starting from a clean slate. Next steps require that you create and edit files using a terminal. A different, more comfortable approach is to attach a visualstudiocode instance to the container and treat it as a normal project. You will need the <code>Remote Explorer</code> extension.</p>"},{"location":"part-1/instructions/#installing-pyenv","title":"Installing <code>pyenv</code>","text":"<p>Install pyenv dependencies and other utilities.</p> <pre><code>apt update &amp;&amp; apt install curl git vim build-essential libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev curl \\\nlibncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev -y\n</code></pre> <pre><code>curl https://pyenv.run | bash\n</code></pre> <p>You will now have <code>pyenv</code> installed. Let's configure it. As per the instructions, we need to add the following to our <code>~/.bashrc</code> file:</p> <pre><code>vim ~/.bashrc\n</code></pre> <p>Go to the end of the file and add the following:</p> <pre><code># Load pyenv automatically by appending\n# the following to\n#~/.bash_profile if it exists, otherwise ~/.profile (for login shells)\n# and ~/.bashrc (for interactive shells) :\n\nexport PYENV_ROOT=\"$HOME/.pyenv\"\ncommand -v pyenv &gt;/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"\neval \"$(pyenv init -)\"\n</code></pre> <p>Save and quit (<code>:wq</code> in vim). Now we need to refresh our shell to load the new configuration:</p> <pre><code>exec \"$SHELL\"\n</code></pre>"},{"location":"part-1/instructions/#installing-python-with-pyenv","title":"Installing python with <code>pyenv</code>","text":"<p>You can now use <code>pyenv</code> to install a new version of python. Let's install version <code>3.10.9</code>:</p> <pre><code>pyenv install 3.10.9\n</code></pre> <p>Let's make it available globally:</p> <pre><code>pyenv global 3.10.9\n</code></pre> <p>We can also install different versions of python and switch between them:</p> <pre><code>pyenv install 3.8.12\n</code></pre>"},{"location":"part-1/instructions/#installing-pipx","title":"Installing <code>pipx</code>","text":"<p>We have now python 3.10.9 installed globally. Let's install <code>pipx</code> with it:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install --user pipx\npython3 -m pipx ensurepath\n</code></pre> <p>Again, we need to refresh our shell to load the new configurations:</p> <pre><code>exec \"$SHELL\"\n</code></pre>"},{"location":"part-1/instructions/#installing-poetry","title":"Installing <code>poetry</code>","text":"<p>Let's install <code>poetry</code> with <code>pipx</code>:</p> <pre><code>pipx install poetry==1.4.2 --force\n</code></pre> <p>And confirm it's installed with:</p> <pre><code>$ poetry --version\nPoetry (version 1.4.2)\n$ whereis poetry\npoetry: /root/.local/bin/poetry\n</code></pre>"},{"location":"part-1/instructions/#configure-poetry","title":"Configure <code>poetry</code>","text":"<p>We want to configure poetry to not create virtual environments by default:</p> <pre><code># configure poetry\npoetry config virtualenvs.create false`\npoetry config virtualenvs.in-project false`\n</code></pre>"},{"location":"part-1/instructions/#creating-a-new-project-with-poetry","title":"Creating a new project with <code>poetry</code>","text":"<p>We can create a new project with poetry named <code>part-1</code>:</p> <pre><code># create project\nmkdir ~/part-1\ncd ~/part-1\n</code></pre> <p>We will now create a virtual environment for this project only</p> <pre><code>pyenv virtualenv 3.10.9 poetry-ws-part-1\npyenv activate poetry-ws-part-1\npyenv rehash # refresh pyenv shims\n</code></pre> <p>Sourcing environment automatically</p> <p>At the project level, type <code>pyenv local poetry-ws-part-1</code> to tell <code>pyenv</code> to source this environment every time you cd into the directory. <code>pyenv</code> will do so by creating a file <code>.python-version</code> at the directory. It does not need to be the name of a virtual environment, a version number e.g. 3.10.9 could also be used.</p> <p>use poetry to create new project with</p> <pre><code>poetry init\n</code></pre> <p>The dialog will ask you a few questions. You can skip them by pressing enter or by passing <code>--no-interaction</code> to the previous command. Skip the part poetry asks you about defining dependencies using the prompt. The dialog will then create a <code>pyproject.toml</code> file. </p> <p>Have a look at it! It should look something like this:</p> <pre><code>[tool.poetry]\nname = \"part-1\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"You &lt;you@mail.something&gt;\"]\nreadme = \"README.md\"\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\n\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>"},{"location":"part-1/instructions/#manage-dependencies-in-your-project","title":"Manage dependencies in your project","text":"<pre><code>poetry add pandas\n</code></pre> <p>and remove dependencies</p> <pre><code>poetry remove pandas\n</code></pre> <p>Every time you <code>add</code> or <code>remove</code> packages with poetry, two things happen:</p> <ul> <li>the <code>pyproject.toml</code> file is updated and a new line is added under the dependencies section</li> <li>a <code>poetry.lock</code> file is created or updated, containing the exact versions of the dependencies you are using and their relations.</li> </ul> <p>Let's install <code>cowsay</code> with <code>poetry</code>:</p> <pre><code>poetry add cowsay\npoetry add --group dev black\npyenv rehash # to update shims\ncowsay hola # a cow should greet you, in spanish\n____\n| hola |\n====\n\\\n\\\n^__^\n       (oo)\\_______\n       (__)\\       )\\/\\\n||----w |\n||     ||\n</code></pre> <p>Go check your <code>pyproject.toml</code> file again with the changes.</p>"},{"location":"part-1/instructions/#writing-your-project-as-a-cli-with-poetry","title":"Writing your project as a CLI with <code>poetry</code>","text":"<pre><code>cd ~/part-1\nmkdir part-1\ntouch part-1/__init__.py\ntouch part-1/cli.py\n</code></pre> <p>Open <code>part-1/cli.py</code> and add the following:</p> <pre><code>import cowsay\n\ndef cli():\n    return cowsay.cow('Hello World')\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>What is a CLI?</p> <p>CLI stands for command line interface. It is a type of software that acts as an interface to another software, and is designed to be executed from a terminal and interact with the user through text. A common example is the <code>git</code> CLI.</p> <p>Confirm that your program works by running it with <code>python part-1/cli.py</code>:</p> <pre><code>$ python part-1/cli.py\n___________\n| Hello World |\n===========\n\\\n\\\n^__^\n              (oo)\\_______\n              (__)\\       )\\/\\\n||----w |\n||     ||\n</code></pre> <p>We can now update our <code>pyproject.toml</code> file to include a CLI entrypoint:</p> <pre><code>[tool.poetry]\nname = \"part-1\"\nversion = \"0.1.0\"\ndescription = \"some description\"\nauthors = [\"Your Name &lt;youremail@yopmail.com&gt;\"]\nreadme = \"README.md\"\npackages = [{include = \"part-1\"}] # new\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\npandas = \"^2.0.0\"\ncowsay = \"^5.0\"\n\n[tool.poetry.scripts]\npart-1-cli = \"part-1.cli:cli\" # new\n\n[tool.poetry.group.dev.dependencies]\nblack = \"^23.3.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre> <p>And now we can install our package with <code>poetry</code> and run our little CLI by calling <code>part-1-cli</code>:</p> <pre><code>poetry install  # install package along with its CLI\npyenv rehash # refresh python shims\n</code></pre> <p>Try it out!</p> <pre><code>part-1-cli # launch cli\n</code></pre>"},{"location":"part-2/instructions/","title":"Building and publishing your project","text":"<p>Make sure you have a valid account at pypi. You can create one here.</p> <p>Run <code>poetry build</code> (at the level where a valid <code>pyproject.toml</code> is present). From this point on, you have two options:</p>"},{"location":"part-2/instructions/#publish-to-pypi","title":"Publish to pypi","text":"<p>Run <code>poetry publish --username myprivaterepo --password &lt;password&gt; --repository pypi</code></p>"},{"location":"part-2/instructions/#publish-to-a-private-repository","title":"Publish to a private repository","text":"<p>if you wish to publish to a private repository, say, <code>pypi.myprivaterepo.org</code>:</p> <ul> <li>Add repository to the <code>config</code> in poetry, with <code>poetry config repositories.myprivaterepo https://pypi.myprivaterepo.org/</code></li> <li>Careful to not add the <code>/simple</code> bit if your privare repo is using <code>pypiserver</code>, see https://github.com/pypiserver/pypiserver/issues/329#issuecomment-688883871</li> <li>now your private pypi ****repository is aliased with <code>myprivaterepo</code></li> </ul> <p>Now you can run <code>poetry publish --username myprivaterepo --password &lt;password&gt; --repository myprivaterepo</code>. See https://python-poetry.org/docs/libraries#publishing-to-pypi for more documentation</p>"},{"location":"part-2/instructions/#creating-your-own-private-repository-using-docker-compose","title":"Creating your own private repository using docker compose","text":"<p>Launch your own pypi repository with https://github.com/pypiserver/pypiserver and https://github.com/pypiserver/pypiserver/blob/master/docker-compose.yml</p>"},{"location":"part-2/instructions/#adding-dependencies-from-private-repositories-to-pyprojecttoml","title":"Adding dependencies from private repositories to pyproject.toml","text":"<p>You may also want to add dependencies from private repositories. These repos normally need keys to access them. Make sure to follow the instructions from your private repository to add credentials to your <code>pyproject.toml</code> file. Generally, the process is as follows:</p> <ol> <li> <p>Add a <code>source</code> to <code>pyproject.toml</code> file</p> </li> <li> <p><code>poetry source add myprivaterepo [https://pypi.](https://pypi.datuma.aiguasol.coop/simple)myprivaterepo.org</code></p> </li> <li> <p>This should modify your <code>pyproject.toml</code> file and will add something like this</p> <pre><code>[[tool.poetry.source]]\nname = \"myprivaterepo\"\nurl = \"https://pypi.myprivaterepo.org/\"\ndefault = false\nsecondary = false\n</code></pre> </li> <li> <p>Add credentials for that repository</p> </li> <li><code>poetry config http-basic.myprivaterepo &lt;user&gt; &lt;password&gt;</code></li> <li>Add dependencies using the <code>--source</code> argument</li> </ol> <pre><code>poetry add --source myprivaterepo my-private-package=0.2.1\n</code></pre> <p>Managing virtual environments inside docker</p> <p>People tend to argue over such scenario. Is isolation within isolation necessary? Is a virtual environment needed inside a docker container? See</p> <ul> <li>https://github.com/python-poetry/poetry/discussions/1879#discussioncomment-346113</li> <li>https://github.com/python-poetry/poetry/pull/3209#issuecomment-710678083</li> </ul> <p>Answer is \u201cit depends\u201d, but it gives more control over dependencies and their state. I prefer it using docker multistage builds. I will cover this in a next post hopefully soon.</p>"}]}